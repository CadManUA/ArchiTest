<?xml version="1.0" encoding="utf-8"?>
<!-- ArchiFrame covering board groups settings etc -->

<!--
Common for every Lua-script - single plank's table fields:
bDoor    true=plank created for door, false=for window
x1,y1    Projection line start
x2,y2    Projection line end
gz1,gz2  Global z-coordinates to detect the lower end
len      plank length
begConn  Begin connection type: 0=none, 1=connected to another end and extension outside the opening(s), 2=connected to middle of another, 3=connected to another end and extension goes inside the opening(s)
endConn  End connection type as begConn
bExtR     true=opening exterior side is at the right side of the plank (default), false=exterior at left side (plank dir swapped at some point)


If found from <findcross>-tag
projx1,projy1 Possibly changed projection line, default is same as x1,y1
projx2,projy2
group     Group name from <planks group="xxx"> attribute
tblCross Table of crossing planks each item having fields
  x,y       Projection lines crossing point
  tblPlankx Crossing plank having every single plank's fields but NOT these <findcross>-items
-->

<archiframe>
  <!-- Settings for cover planks -->
  <cover>
    <settings>
      <!-- Common settings -->
      <plank>
        <misc minlen="0.050" layer="Cover boards" floor="*constructional storey 1*"></misc>
      </plank>

      <lines>
        <!-- Names & values for different material to be used between frames. If type is given, it will be used instead of line type name based on geometry. Also edge will be set as middle line for the plank. -->
        <!-- If type is omitted, the edge is handled as normal type but the material type comes from here -->
        <combinelines id="cover_out">
          <combine maxdist="0.020" settype="combine20">
            <material id="block" thickness="0.020" height="0.050" zoff="jamb_depth-mat_thickness*0.5" linexoff="-mat_height*0.5" rotangle="90"></material>
          </combine>
          <combine maxdist="0.111">
            <!-- Use type's default material -->
          </combine>
          <combine maxdist="0.136">
            <material id="block" thickness="0.023" height="0.145" zoff="-mat_thickness*0.5" rotangle="90"></material>
          </combine>
        </combinelines>

        <!-- The same for inner cover planks -->
        <combinelines id="cover_in">
          <combine maxdist="0.020" settype="combine20">
            <material id="block" thickness="0.015" height="0.050" zoff="jamb_depth-mat_thickness*0.5" linexoff="-mat_height*0.5" rotangle="90"></material>
          </combine>
          <combine maxdist="0.111">
            <!-- Use type's default material -->
          </combine>
          <combine maxdist="0.136">
            <material id="block" thickness="0.023" height="0.145" zoff="-mat_thickness*0.5" rotangle="90"></material>
          </combine>
        </combinelines>
      </lines>

      <!-- Settings for new plank for cover plank -->
      <newplank>
        <elemparam name="pen">5</elemparam>
        <objparam name="iShowID">0</objparam>
        <objparam name="iShowID3D">0</objparam>
        <objparam name="iPenErr">1</objparam>
        <objparam name="iPenLocked">1</objparam>
        <objparam name="iShowIn2D">0</objparam>
        <objparam name="iUsageId">WEATHER</objparam>
        <objparam name="#id">WB-[parentid]</objparam>
      </newplank>

      <!-- To be referenced later (to allow having just one definition for similar types) -->
      <!-- Operations are run for final planks (offseted and extended) -->
      <op_presets>
        <!-- Operations are run for final planks (offseted and extended) -->
        <operations id="basic">
          <!-- Angled cut for vertical planks connected with angled planks (inclined openings) -->
          <jointo target="inclined*" operator="vertical*">
            <cut conntype="endtoend|linex" toend="1" expandopfind="0.010" maxdisttoend="0.030"></cut>
          </jointo>

          <!-- Joining horizontal|inclined together -->
          <joinends target="horizontal*|inclined*" operator="horizontal*|inclined*">
            <joinends conntype="endtoend|linex" jointgap="0.000"></joinends>
          </joinends>

          <!-- Any T-joint -->
          <jointo target="*" operator="*">
            <cut conntype="endtoline" jointgap="0.000" mindisttoend="0.020"></cut>
          </jointo>

          <!-- Adjust inclined not connected with T-joint  -->
          <jointo target="vertical*" operator="inclined*">
            <cut conntype="linex" jointgap="0.000"></cut>
          </jointo>

          <!-- To adjust in case of combined openings and horizontal extended inside vertical -->
          <jointo target="horizontal*" operator="vertical*">
            <cut conntype="hasx" jointgap="0.000"></cut>
          </jointo>

          <!-- To fix in case of combined openings and horizontal extended over the vertical -->
          <jointo target="horizontal*" operator="vertical*">
            <cut conntype="linetoend" disttoend="0.120" toend="1" expandopfind="0.001"></cut>
          </jointo>
        </operations>
      </op_presets>
    </settings>

    <covertypes>
      <covertype id="AF BASIC INT" name="Basic interior" oversize="0">
        <!-- Default settings for this element type -->
        <settings>
          <newplank>
          </newplank>

          <combinelines ref="cover_in">
          </combinelines>
        </settings>

        <create>
          <linegroup>
            <!-- Vertical planks extended from bottom -->
            <planks door="0" group="vertical" type="vertical*" lineoff="-0.010" extendtop="0" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="vertical" type="vertical*" lineoff="-0.0075" extendtop="0" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontal|horizontaltop" lineoff="-0.010" extend="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontalbot" lineoff="-0.010" extend="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="horizontal" type="horizontal|horizontaltop" lineoff="-0.0075" extend="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="horizontal" type="horizontalbot" lineoff="-0.0075" extend="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <!-- Inclined for operations later -->
            <planks group="inclined" type="inclinedtop*" lineoff="-0.010">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks group="combine20" type="combine20">
              <material>Material set in combinelines-definition, must have material tag here too</material>
            </planks>
          </linegroup>

          <!-- Jamb covering from wall surface inside the wall to the frame  -->
          <!-- type="jamb" gives more rules: Must be normal on top of jamb, use original opening frame edges (not combined edges) to get double jambs for two neighbour openings -->
          <linegroup type="jamb">
            <!--  -->
            <planks door="0" group="jamb_vertical" type="vertical*" extend="0.0075" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_vertical" type="vertical*" extendtop="0.0075" extendbot="0.000" lineoff="-0.0075+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks door="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.0075+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <!-- Bottom jamb only for windows -->
            <planks door="0" group="jamb_bot" type="horizontalbot" extend="0.000" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

          </linegroup>

          <!-- Operations are run for final planks (offseted and extended) -->
          <operations ref="basic">
          </operations>
        </create>
      </covertype>
      
      
      <!-- Tässä oville vuorilauta myös alas -->
      <covertype id="AF DECO INT" name="Decorative interior" oversize="0">
        <!-- Default settings for this element type -->
        <settings>
          <newplank>
          </newplank>

          <combinelines ref="cover_in">
          </combinelines>
        </settings>

        <create>
          <linegroup>
            <!-- Vertical planks extended -->
            <planks door="0" group="vertical" type="vertical*" lineoff="-0.010" extendtop="0.120" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="vertical" type="vertical*" lineoff="-0.0075" extendtop="0.120" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontal|horizontaltop|horizontalbot" lineoff="-0.010">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="horizontal" type="horizontal|horizontaltop|horizontalbot" lineoff="-0.0075">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <!-- Inclined for operations later - only windows here -->
            <planks group="inclined" type="inclinedtop*" lineoff="-0.010">
              <material id="block" thickness="0.018" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks group="combine20" type="combine20">
              <material>Material set in combinelines-definition, must have material tag here too</material>
            </planks>
          </linegroup>

          <!-- Jamb covering from wall surface inside the wall to the frame  -->
          <!-- type="jamb" gives more rules: Must be normal on top of jamb, use original opening frame edges (not combined edges) to get double jambs for two neighbour openings -->
          <linegroup type="jamb">
            <!--  -->
            <planks door="0" group="jamb_vertical" type="vertical*" extend="0.0075" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_vertical" type="vertical*" extendtop="0.0075" extendbot="0.0075" lineoff="-0.0075+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks door="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.0075+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <!-- Bottom jamb only for windows -->
            <planks door="0" group="jamb_bot" type="horizontalbot" extend="0.000" lineoff="-0.010+0.015/2">
              <material id="block" thickness="0.015" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>
          </linegroup>

          <!-- Operations are run for final planks (offseted and extended) -->
          <operations ref="basic">
          </operations>


          <!-- Add decorations etc, projects plank lines possibly changed in operations-section -->
          <scriptplanks>
            <!-- Decoration pieces -->
            <findcross resulttbl="gtblCorners">
              <base name="vertical*"></base >
              <cross name="horizontal*|inclined*" maxdist="0.150" linepos="mid"></cross>
            </findcross>

            <!-- When creating new plank, these settings will be taken (force length to 120 mm for better 3D) -->
            <default>
              <material id="block" thickness="0.020" height="0.120" zoff="-0.018-mat_thickness*0.5" rotangle="90" fixlen="0.120">
                <objparam name="iUsageId">WEATHER-CORNER</objparam>
                <objparam name="#id">WBCORNER</objparam>
              </material>
            </default>

            <!-- Script defines new planks -->
            <script>
              <![CDATA[
-- Lua script, see ArchiFrame manual
-- ArchiFrame sets global tables (defined in xml above) for plank having fields descripted at beginning of the file. begConn and endConn not set.

-- This is the result tbl. Every plank has fields (some fields may be left unset):
-- group="name"
--   for possible <operations>-tag later
-- id="material_id"
-- thickness=meters (only if material_id does not set size)
-- height=meters (only if material_id does not set size)
-- zoff=meters
-- rotangle=angledeg (added to the existing value)
--  these values as <planks> and <material>-tag
-- x1,y1,x2,y2
--  position of the new plank in projection plane (z neg moves away from the wall surface)

gnPlankCount=0
gtblCreate = {}

function Do()
  if gtblCorners~=nil then
    DoCorners()
  end
end


gnUsedCorner=0
gtblUsedCorner = {}

-- Checks that this place is not already used
-- Returns: true=ok and pos added, false=nope, don't add
function CanAddNewCorner(x,y)
  local i,v
  
  for i,v in ipairs(gtblUsedCorner) do
    if math.abs(x-v.x)<0.120 and math.abs(y-v.y)<0.120 then
      return false
    end
  end
  
  gnUsedCorner=gnUsedCorner+1
  gtblUsedCorner[gnUsedCorner]={}
  gtblUsedCorner[gnUsedCorner].x=x
  gtblUsedCorner[gnUsedCorner].y=y
  return true
end


function DoCorners()
  local iVert, tblVert, iCross, tblCross, tblNew, dx, dy, nx, ny, x, y
  
  for iVert, tblVert in ipairs(gtblCorners) do
    for iCross, tblCross in ipairs(tblVert.tblCross) do
      if CanAddNewCorner(tblCross.x, tblCross.y) then
  	    --ac_msgbox( string.format("tblCross.x=%.3f tblCross.y=%.3f", tblCross.x, tblCross.y) )
        tblNew={}
        tblNew.group="script_piece"
        --From default: tblNew.zoff=-0.021
        --From default: tblNew.rotangle=180
        x=tblCross.x
        y=tblCross.y
        
        -- Move 1 cm over the joint, default to left
        dx=tblVert.x2-tblVert.x1
        dy=tblVert.y2-tblVert.y1
        len=math.sqrt(dx*dx+dy*dy)
        if len>0.001 then
          dx=dx/len
          dy=dy/len
        end
        nx=-dy
        ny=dx

        if tblVert.bExtR==false then
          -- Change dir
          nx=-nx
          ny=-ny
          tblNew.rotangle=180
        end

        x=x+nx*0.010
        y=y+ny*0.010
        x=x-dx*0.060
        y=y-dy*0.060
        tblNew.x1=x
        tblNew.y1=y
        tblNew.x2=x+dx*0.120    -- Side of the plank
        tblNew.y2=y+dy*0.120
        tblNew.fixlen = 0.120   -- For better 3D

        gnPlankCount=gnPlankCount+1
        gtblCreate[gnPlankCount]=tblNew
      end
    end
  end
end
]]>
            </script>
          </scriptplanks>
        </create>
      </covertype>



      <covertype id="AF BASIC EXT" name="Basic exterior" oversize="0">
        <!-- Default settings for this element type -->
        <settings>
          <newplank>
          </newplank>

          <combinelines ref="cover_out">
          </combinelines>
        </settings>

        <create>
          <linegroup>
            <!-- Vertical planks extended from bottom -->
            <planks door="0" group="vertical" type="vertical*" lineoff="-0.010" extendtop="0" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="vertical" type="vertical*" lineoff="-0.0075" extendtop="0" extendbot="0.000" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontal|horizontaltop" lineoff="-0.010" extend="0.120" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontalbot" lineoff="-0.010" extend="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks window="0" group="horizontal" type="horizontal|horizontaltop" lineoff="-0.0075" extend="0.120" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <!-- Inclined for operations later -->
            <planks group="inclined" type="inclined*" lineoff="-0.010">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks group="combine20" type="combine20">
              <material>Material set in combinelines-definition, must have material tag here too</material>
            </planks>
          </linegroup>

          <!-- Jamb covering from wall surface inside the wall to the frame  -->
          <!-- type="jamb" gives more rules: Must be normal on top of jamb, use original opening frame edges (not combined edges) to get double jambs for two neighbour openings -->
          <linegroup type="jamb">
            <!--  -->
            <planks door="0" group="jamb_vertical" type="vertical*" extend="0.0075" lineoff="-0.010+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_vertical" type="vertical*" extendtop="0.0075" extendbot="0.000" lineoff="-0.0075+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks door="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.010+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks window="0" group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.0075+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <!-- No bottom jamb -->
            <!-- planks door="0" group="jamb_bot" type="horizontalbot" extend="0.000" lineoff="-0.010+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks -->
          </linegroup>

          <operations ref="basic">
          </operations>
        </create>
      </covertype>



      <covertype id="AF DECO EXT" name="Decorative exterior" oversize="0">
        <!-- Default settings for this element type -->
        <settings>
          <newplank>
          </newplank>

          <combinelines ref="cover_out">
          </combinelines>
        </settings>

        <create>
          <linegroup>
            <!-- Vertical planks extended -->
            <planks door="0" group="vertical" type="vertical*" lineoff="-0.010" extendtop="0.120" extendbot="0.195" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
              <!-- Script is handled after every line in the group has been processed to be able to calculate begConn & endConn -->
              <script>
                <![CDATA[
-- Lua script, see ArchiFrame manual
-- ArchiFrame sets global table gPlank having fields descripted at beginning of the file

-- Returns: true=ok, false=do not create the plank
function HandlePlank()
  if gPlank.bDoor==true or gPlank.len<0.2 then
    return true
  end
  
  gnMc=0
  if gPlank.gz1<gPlank.gz2 then
    AddDecoBeg()
  else
    AddDecoEnd()
  end

  return true
end

-- Zero
function InitNewMc()
  local i
  
  -- Make sure everything is zero
  gnMc=gnMc+1
  for i=1,16 do
    ac_objectset("iMc", 0,  gnMc, i )
  end
  ac_objectset("iMcStr", "",  gnMc )
end


function AddDecoBeg()
  if gPlank.begConn~=0 then
    return
  end

  InitNewMc()
  ac_objectset("iMc", 100,    gnMc, 1 )      -- mc code
  ac_objectset("iMc", 0,      gnMc, 2 )      -- angle top
  ac_objectset("iMc", -45,    gnMc, 3 )      -- angle side
  ac_objectset("iMc", 0,      gnMc, 4 )      -- straight top
  ac_objectset("iMc", 0.100,  gnMc, 5 )     -- straight side

end


function AddDecoEnd()
  local x

  if gPlank.endConn~=0 then
    return
  end

  InitNewMc()
  ac_objectset("iMc", 200,    gnMc, 1 )      -- mc code
  ac_objectset("iMc", 0,      gnMc, 2 )      -- angle top
  ac_objectset("iMc", 45,     gnMc, 3 )      -- angle side
  ac_objectset("iMc", 0,      gnMc, 4 )      -- straight top
  ac_objectset("iMc", 0.100,  gnMc, 5 )      -- straight side
end
]]>
              </script>
            </planks>

            <planks window="0" group="vertical" type="vertical*" lineoff="-0.010" extendtop="0.120" extendbot="0.120" extendt="0">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <!-- Horizontal separate to distinguish inclined from horizontal -->
            <planks group="horizontal" type="horizontal|horizontaltop" lineoff="-0.010">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks door="0" group="horizontal" type="horizontalbot" lineoff="-0.010">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <!-- Inclined for operations later -->
            <planks group="inclined" type="inclinedtop*" lineoff="-0.010">
              <material id="block" thickness="0.022" height="0.120" zoff="-mat_thickness*0.5" rotangle="90"></material>
            </planks>

            <planks group="combine20" type="combine20">
              <material>Material set in combinelines-definition, must have material tag here too</material>
            </planks>
          </linegroup>

          <linegroup>
            <!-- Weatherboard -->
            <planks group="weatherboard" type="horizontaltop|inclinedtop" lineoff="0.120" extendfree="0.170">
              <material id="block" thickness="0.022" height="0.180" zoff="0.000" rotangle="-135">
                <objparam name="iUsageId">WEATHER-VISOR</objparam>
              </material>
              <script>
                <![CDATA[
-- Lua script, see ArchiFrame manual
-- ArchiFrame sets global table gPlank having fields descripted at beginning of the file

PI=3.141592653589793

function DegToRad(a)
  return a*PI/180.0
end

-- Returns: true=ok, false=do not create the plank
function HandlePlank()
  local angle, a, rotAngle
  
  if gPlank.len<0.2 then
    return true
  end
  
  -- Adjust angle if not straight
  angle=math.atan2(gPlank.y2-gPlank.y1, gPlank.x2-gPlank.x1)
  a=DegToRad(36.75)*math.abs(math.cos(angle))    -- 36.75 is weatherboard angle
  rotAngle=ac_objectget("iRotAngle")
  if rotAngle<0 then
    rotAngle=rotAngle-DegToRad(36.75)+a
  else
    rotAngle=rotAngle+DegToRad(36.75)-a
  end
  ac_objectset("iRotAngle", rotAngle)

  gnMc=0
  if gPlank.begConn==0 then
    AddDecoBeg()
  end
 
  if gPlank.endConn==0 then
    AddDecoEnd()
  end
  return true
end

-- Zero
function InitNewMc()
  local i
  
  -- Make sure everything is zero
  gnMc=gnMc+1
  for i=1,16 do
    ac_objectset("iMc", 0,  gnMc, i )
  end
  ac_objectset("iMcStr", "",  gnMc )
end


function AddDecoBeg()
  InitNewMc()
  ac_objectset("iMc", 100,    gnMc, 1 )      -- mc code
  ac_objectset("iMc", 0,      gnMc, 2 )      -- angle top
  ac_objectset("iMc", -45,    gnMc, 3 )      -- angle side
  ac_objectset("iMc", 0,      gnMc, 4 )      -- straight top
  ac_objectset("iMc", 0.120,  gnMc, 5 )      -- straight side
end


function AddDecoEnd()
  InitNewMc()
  ac_objectset("iMc", 200,    gnMc, 1 )      -- mc code
  ac_objectset("iMc", 0,      gnMc, 2 )      -- angle top
  ac_objectset("iMc", 45,     gnMc, 3 )       -- angle side
  ac_objectset("iMc", 0,      gnMc, 4 )      -- straight top
  ac_objectset("iMc", 0.120,  gnMc, 5 )      -- straight side
end
]]>
              </script>
            </planks>

            <!-- Just to calculate the lines, group="" is needed for extendfree to work -->
            <planks group="" type="vertical*|horizontalbot|horizontal|inclinedbot|inclined" lineoff="-0.010">
            </planks>
          </linegroup>

          <!-- Jamb covering from wall surface inside the wall to the frame  -->
          <!-- type="jamb" gives more rules: Must be normal on top of jamb, use original opening frame edges (not combined edges) to get double jambs for two neighbour openings -->
          <linegroup type="jamb">
            <!--  -->
            <planks group="jamb_vertical" type="vertical*" extendtop="0.023/2" lineoff="-0.010+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>

            <planks group="jamb_other" type="horizontaltop|horizontal|inclined*" extend="0.000" lineoff="-0.010+0.023/2">
              <material id="block" thickness="0.023" height="jamb_depth+wall_distance" zoff="0.000" rotangle="0">
                <objparam name="iUsageId">WEATHER-JAMB</objparam>
                <objparam name="#id">WBJAMB-[parentid]</objparam>
              </material>
            </planks>
          </linegroup>


          <operations ref="basic">
          </operations>

          <!-- Add decorations etc, projects plank lines possibly changed in operations-section -->
          <scriptplanks>
            <findcross resulttbl="gtblWeather">
              <base name="weatherboard"></base >
              <cross name="vertical*" maxdist="0.150" linepos="mid"></cross>
            </findcross>

            <!-- When creating new plank, these settings will be taken -->
            <default>
              <material id="block" thickness="0.023" height="0.120" zoff="-0.021" rotangle="180">
                <objparam name="iUsageId">WEATHER-SUPP</objparam>
                <objparam name="#id">WBSUPP</objparam>
              </material>
            </default>

            <!-- Script defines new planks -->
            <script>
              <![CDATA[
-- Lua script, see ArchiFrame manual
-- ArchiFrame sets global tables (defined in xml above) for plank having fields descripted at beginning of the file. begConn and endConn not set.

-- This is the result tbl. Every plank has fields (some fields may be left unset):
-- group="name"
--   for possible <operations>-tag later
-- id="material_id"
-- thickness=meters (only if material_id does not set size)
-- height=meters (only if material_id does not set size)
-- zoff=meters
-- rotangle=angledeg (0=the looking direction inside the wall)
--  these values as <planks> and <material>-tag
-- x1,y1,x2,y2
--  position of the new plank in projection plane (z neg moves away from the wall surface)

gnPlankCount=0
gtblCreate = {}

function Do()
  if gtblWeather~=nil then
    DoWeather()
  end
end



gnUsedWeather=0
gtblUsedWeather = {}

-- Checks that this place is not already used
-- Returns: true=ok and pos added, false=nope, don't add
function CanAddNewWeather(x,y)
  local i,v
  
  for i,v in ipairs(gtblUsedWeather) do
    if math.abs(x-v.x)<0.100 and math.abs(y-v.y)<0.100 then
      return false
    end
  end
  
  gnUsedWeather=gnUsedWeather+1
  gtblUsedWeather[gnUsedWeather]={}
  gtblUsedWeather[gnUsedWeather].x=x
  gtblUsedWeather[gnUsedWeather].y=y
  return true
end


function DoWeather()
  local iWeather, tblWeather, iCross, tblCross, tblNew, h, x1, y1, dx, dy, dist, lenFromStart
  
  for iWeather, tblWeather in ipairs(gtblWeather) do
    -- Calculate position/pos for each point
    x1=tblWeather.x1
    y1=tblWeather.y1
    for iCross, tblCross in ipairs(tblWeather.tblCross) do
      dx=tblCross.x-x1
      dy=tblCross.y-y1
      tblCross.pos=math.sqrt(dx*dx + dy*dy)
      tblCross.count=iCross
    end
		table.sort(tblWeather.tblCross, function (n1, n2)
			if math.abs(n1.pos-n2.pos)>0.001 then
				return n1.pos < n2.pos		-- compare the sort key
			end
			
			return n1.count < n2.count		-- Keep the order if at same pos
		end)

    for iCross, tblCross in ipairs(tblWeather.tblCross) do
  	  --ac_msgbox( string.format("tblCross.x=%.3f tblCross.y=%.3f tblCross.tblPlankx.projy1=%.3f tblCross.tblPlankx.projy2=%.3f", tblCross.x, tblCross.y, tblCross.tblPlankx.projy1, tblCross.tblPlankx.projy2) )
      tblNew={}
      if iCross==1 or iCross==table.getn(tblWeather.tblCross) then
        -- Big one only for first and last crossing
        tblNew.id="COVER DECO1"
        h=0.250
      end

      -- Check if L corner here and need to use smaller deco (check if support goes below the vertical plank)
      y1=tblCross.tblPlankx.y1
      if y1>tblCross.tblPlankx.y2 then
        y1=tblCross.tblPlankx.y2
      end
      if tblCross.y-h-0.010<y1 then
        tblNew.id=nil
      end

      if tblNew.id==nil then
        tblNew.id="COVER DECO2"
        h=0.157
      end
        
      tblNew.group="weather_support"
      --From default: tblNew.zoff=-0.021
      --From default: tblNew.rotangle=180
      tblNew.x1=tblCross.x
      tblNew.y1=tblCross.y

      dist, lenFromStart=ac_geo("linex", 0, 0, 1,1, 0,1, 1,0)

      dist, lenFromStart=ac_geo("linedist", tblWeather.x1, tblWeather.y1, tblWeather.x2, tblWeather.y2, tblCross.x, tblCross.y)
      if lenFromStart<0.010 then
        -- Extended cross pt outside the weather board - must be T-joint
        tblNew.id="COVER DECO2"
        h=0.157
        tblNew.x1=tblWeather.x1+(tblWeather.x2-tblWeather.x1)/tblWeather.len*0.010
        tblNew.y1=tblWeather.y1+(tblWeather.y2-tblWeather.y1)/tblWeather.len*0.010
      elseif lenFromStart+0.010>tblWeather.len then
        -- Extended cross pt outside the weather board - must be T-joint
        tblNew.id="COVER DECO2"
        h=0.157
        tblNew.x1=tblWeather.x2-(tblWeather.x2-tblWeather.x1)/tblWeather.len*0.010
        tblNew.y1=tblWeather.y2-(tblWeather.y2-tblWeather.y1)/tblWeather.len*0.010
      end

      tblNew.x2=tblNew.x1
      tblNew.y1=tblNew.y1-0.035-h
      tblNew.y2=tblNew.y1+h

      if CanAddNewWeather(tblNew.x1, tblNew.y1) then
        gnPlankCount=gnPlankCount+1
        gtblCreate[gnPlankCount]=tblNew
      end

      if iCross>1 then
        -- If length>1.9m, add small support
        local n, i, dist, dp, dist
        
        dp=tblCross.pos-tblWeather.tblCross[iCross-1].pos
        n=math.floor((dp-0.001)/1.9)
        dist=dp/(n+1)
        --ac_msgbox(string.format("dp=%.3f n=%f dist=%f", dp, n, dist))
        for i=1,n do
          tblNew={}
          tblNew.id="COVER DECO2"
          h=0.157


          tblNew.group="weather_support"
          --From default: tblNew.zoff=-0.021
          --From default: tblNew.rotangle=180
          tblNew.x1=tblWeather.tblCross[iCross-1].x + i*dist / dp * (tblCross.x-tblWeather.tblCross[iCross-1].x)
          tblNew.y1=tblWeather.tblCross[iCross-1].y + i*dist / dp * (tblCross.y-tblWeather.tblCross[iCross-1].y)
          tblNew.y1=tblNew.y1-0.035-h
          tblNew.x2=tblNew.x1
          tblNew.y2=tblNew.y1+h

          if CanAddNewWeather(tblNew.x1, tblNew.y1) then
            gnPlankCount=gnPlankCount+1
            gtblCreate[gnPlankCount]=tblNew
          end
        end
      end
      
    end
  end
end

]]>
            </script>
          </scriptplanks>

        </create>
      </covertype>

    </covertypes>

    <openings_script>
<![CDATA[
-- Lua script, see ArchiFrame manual
-- Gives ArchiFrame the frame outline COUNTER-CLOCKWISE. Information is returned in table gPoints
-- ArchiFrame applies mirroring if any - do not take those into account here
-- gPoints indexing starts from 1 and each element has fields:
-- x,y  The point
-- If the script does not return edges, ArchiFrame uses standard parameters to create frame rectangle
--
-- Also gives window frame thickness, and frame positioning in the wall in these globals:
-- gFrameThick  nil=use default, value=the thickness
-- gFrameAnchor nil=use default, 0=frame anchored to inner side of the wall, 1=anchored to exterior side of the wall
-- gFrameMove   nil=use default, value=move frame this value from the anchor surface towards other side
-- gForceType   nil=let opening be door/window as defined in AC, 4=window, 5=door



-- Table of library part guids to skip, in lowercase!!!
gtblSkipOpenings = {}
gtblSkipOpenings["{9647310c-5bd5-4874-8c3f-fee520ec1820}"]=1      -- Empty opening
gtblSkipOpenings["{80e9ba91-1494-4e24-85a7-a092857fb5c8}"]=1      -- Empty door
gtblSkipOpenings["{dac0743f-6d46-4ba6-be86-504169eec9b4}"]=1      -- AC16 Simple Window opening
gtblSkipOpenings["{addd8615-abd0-4e9d-8ee4-ebd7dac87cf4}"]=1      -- AC16 Simple Door opening
gtblSkipOpenings["{05a15b9b-aa9a-4d38-ae53-95c335cfa1bb}"]=1      -- AC18 Simple Window opening
gtblSkipOpenings["{f6fab810-3a56-4c74-8eb8-b58738a9ee9b}"]=1      -- AC18 Simple Door opening
gtblSkipOpenings["{8c6b9ebc-3e91-6645-a4cd-277c7dd8cd9a}"]=1      -- LogsOpening win
gtblSkipOpenings["{211329a8-496a-4b98-a9f0-390fbebc743c}"]=1      -- LogsOpening door
gtblSkipOpenings["{44ec9add-178d-4f1e-a001-fc1e44d4718b}"]=1      -- LogsWallEnd

-- Honka:
gtblSkipOpenings["{d5de915f-b155-4f2e-a560-7efcdc041a1e}"]=1      -- Balluster for holes
gtblSkipOpenings["{50d3532b-c924-45e0-8137-328c800f2919}"]=1      -- Balluster for holes 2
gtblSkipOpenings["{6bcdf721-b18c-406c-88ec-300d2cbf47de}"]=1      -- Star opening
gtblSkipOpenings["{c12addc8-9e4e-4298-83e3-010eb972f2d7}"]=1      -- Star opening symmetric
gtblSkipOpenings["{71721f26-3fa8-4444-9138-8864082c55cd}"]=1      -- Cantilever R
gtblSkipOpenings["{6b7f3ef4-0b4c-45c4-a110-d91898f15433}"]=1      -- Cantilever S
gtblSkipOpenings["{5439da6f-25d3-4d1f-ab66-7ed61e615cac}"]=1      -- Log footing R
gtblSkipOpenings["{97742c06-c691-459e-9cef-f28dc6cdf0ff}"]=1      -- Log footing S
gtblSkipOpenings["{68c6045d-55ac-4811-bf80-8b7a13e973f1}"]=1      -- Window divisor
gtblSkipOpenings["{52e617dc-e3ad-4e52-bab5-fc12e3752e1e}"]=1      -- Empty window
gtblSkipOpenings["{af074cd5-d5a9-4000-bc64-01c2ea573299}"]=1      -- Empty-door
--gtblSkipOpenings[""]=1      -- 

-- Force type
gtblForceType={}
gtblForceType["{8ee8208d-34c0-4b85-94b9-3b9bf255885f}"]=5         -- DK-windowdoor wo grille
gtblForceType["{d792ed02-c115-4c81-9d81-77ad51170cac}"]=5         -- DKT-doublewindowdoor
gtblForceType["{1791eaad-58ec-421e-a116-fb4d3cab011f}"]=5         -- DKT-windowdoor-02
gtblForceType["{ab8cee45-6f36-4bf8-b17d-417d32e5ee10}"]=5         -- DK-windowdoor
gtblForceType["{80a6306c-d5f6-453b-a784-aeac676ef341}"]=5         -- DK-windowdoubledoor
gtblForceType["{ab5316cc-276f-4159-9b6b-ffdf79d1876b}"]=5         -- PSK-doublewindowdoor

-- Called to each opening, unidSource is guid of the opening to handle
-- Returns: true=some or all information set, skip opening if no points, false=nothing set
function GetOpeningData(unidSource)
  local offset, fd, wt, sill
  local i1, i2, sGuid

  gFrameThick=nil
  gFrameAnchor=nil
  gFrameMove=nil
  gForceType=nil
  gPoints = nil
  gnPoints=0

  ac_objectopen(unidSource)
  gA=ac_objectget("A")
  gA2=gA*0.5
  gB=ac_objectget("B")
  
  -- # Honka openings frame thickness & offset
  offset=ac_objectget("offset")
  fd=ac_objectget("fd")
  wt=ac_objectget("wt")
  sill=ac_objectget("#wido_sill")
  if offset~=nil and fd~=nil and wt~=nil then
    -- Assume Honka opening
    gFrameThick=fd
    gFrameAnchor=0
    gFrameMove=-wt      -- This is "additional wall thickness" and moves frame outside from the surface
    if offset==0 then
      gFrameAnchor=1
    end
    if math.abs(sill)>0.0005 then
      -- Changes anchor to exterior side and move comes here (forget about additional wall thickness)
      gFrameAnchor=1
      gFrameMove=sill
    end
  end
  
  -- # GUID of the libpart, first part only
  sGuid=string.lower(ac_objectget("#libguid"))      -- NOTE! Lowercase
  i1,i2=string.find( sGuid, "}-{", 1, true )
  if i1==nil then
    error( "Bad guid: " .. sGuid )
  end
  
  sGuid=string.sub(sGuid, 1, i1)
  --ac_environment( "tolog", sGuid )

  gForceType=gtblForceType[sGuid]
  
  -- Openings to skip
  if gtblSkipOpenings[sGuid]~=nil then
    return true
  end

  -- # Outline
  gPoints = {}

  if HandleStandardOpening(sGuid) then
    return true
  end
  
  if HandlePK21(sGuid) then
    return true
  end

  if sGuid=="{361794e1-25ac-46a2-ab0d-7924ca4d32ce}" or sGuid=="{f0c53e2b-ad05-471a-b83c-4ac8e4a6b9a2}" or sGuid=="{938990ca-ce80-4924-9e77-bc5ae43296b9}" or sGuid=="{361d5c23-b5f3-4bd5-b831-7bd8ac8cc9e8}" or sGuid=="{d74cea70-21e3-482d-a6ac-8a0604abe8c2}" or sGuid=="{b785b4fc-c3cb-48d2-8910-d1c23f33b262}" or sGuid=="{53b58259-6506-4422-8e4a-239c672492fe}" then
    return DoPihla()
  end

  if sGuid=="{d9945ace-44d6-44a2-a51e-b663c86ebd80}" or sGuid=="{f4ed55bd-f529-4784-8a85-60637b20aad8}" or sGuid=="{83362439-3338-46a4-99d0-da60ae8d533d}" or sGuid=="{564e124b-9e11-4a03-a297-21bb2ca9e9d8}" or sGuid=="{0b6aff96-5f0b-46e0-971a-01c2f0fd0f5b}" or sGuid=="{05cb760a-dacb-4765-9b12-9743cf5fcafe}" then
    return DoLasita()
  end
  
  if sGuid=="{0409ad48-ba29-f849-a1ae-9c2bdeab3fb5}" then
    return DoLasita2021()
  end
  
  s=string.lower(ac_objectget("#libname"))
  if s=="fw_angle_1" or s=="fw_angle_2" or s=="fw_angle_3" or s=="fw_angle_4" or s=="re-anglewindow" then
    return DoHonkaAngled()
  end
  
  if s=="fw_triangle_asymmetry_1" or s=="fw_triangle_asymmetry_2" or s=="re-window_triangle" or s=="re-fire-exit" then
    return DoHonkaTriangleAsym()
  end

  if s=="fw_triangle_symmetry_1" or s=="fw_triangle_symmetry_2" or s=="fw_triangle_symmetry_3" or s=="fw_triangle_symmetry_4" or s=="dk-window_triangle" then
    return DoHonkaTriangleSym()
  end

  if s=="honka window" then
    return DoHonkaWindow()
  end

  return false
end


function AddPoint(x, y)
  local tblNew

  tblNew={}
  tblNew.x = x
  tblNew.y = y

  gnPoints=gnPoints+1
  gPoints[gnPoints] = tblNew
end


-- Handles AC standard non-rectangular openings
function HandleStandardOpening(sGuid)
  local xc,yc
  
--ac_environment("tolog", string.format("guid=%s", sGuid))
  if sGuid=="{77ce5643-29cb-422b-9f37-0c14188d5f28}" or sGuid=="{f5a82f0c-fa24-4ed7-a165-76378c98d635}" or sGuid=="{8be7164d-2d4d-4108-b429-d5ea82420bd3}" then
    -- W Triangle fix
    xc = ac_objectget("tec") 
    if xc==nil then
      return false
    end
    
    AddPoint( -gA2, 0 )
    AddPoint( gA2, 0 )
    AddPoint( xc, gB )
    return true
  end

  if sGuid=="{a668efe1-61ad-4f3c-b91b-2858f72e6e95}" or sGuid=="{085df0be-a0f7-4c8e-b74f-2fe70512b55d}" or sGuid=="{2d19806d-b52d-413b-ac7c-8f5be4770019}" or sGuid=="{44fa57e3-7a05-4e54-a4e9-29d38d8788be}" or sGuid=="{dee95537-a350-4d46-af12-54aab5d2161e}" then
    -- W Puolisuunnikas kiinteä, Trapezoid
    yc = ac_objectget("h") 
    if yc==nil then
      yc=ac_objectget("gs_shoulderHeight") 
      if yc==nil then
        return false
      end
    end
    
    AddPoint( -gA2, 0 )
    AddPoint( gA2, 0 )
    AddPoint( gA2, gB )
    AddPoint( -gA2, yc )
    return true
  end

 
  if sGuid=="{53675399-65b4-4441-9957-8f36aac723e1}" or sGuid=="{f5ac36f1-e8da-443e-8c7b-2cdd33999218}" then
    -- W Pentagon
    yc=ac_objectget("gs_shoulderHeight") 
    if yc==nil then
      return false
    end
    
    AddPoint( -gA2, 0 )
    AddPoint( gA2, 0 )
    AddPoint( gA2, yc )
    AddPoint( 0, gB )
    AddPoint( -gA2, yc )
    return true
  end

  if sGuid=="{98a5fbf7-d09e-42d7-8e6e-54b3ec19a0f3}" or sGuid=="{ce0e5c7b-9703-4268-89ba-278d2b1ca587}" then
    -- Diamond (vinoneliö), Rhombus ac26
    AddPoint( 0, 0 )
    AddPoint( gA2, gB*0.5 )
    AddPoint( 0, gB )
    AddPoint( -gA2, gB*0.5 )
    return true
  end

  return false
end


function HandlePK21(sGuid)
  local xc,yc

--ac_environment( "tolog", sGuid )
  if sGuid=="{d6d8f5ca-288d-11d7-ae90-0003936c66dc}" then
    -- Monikulmioikkuna PK21
    local muoto, y1, y2, y3

    -- Aloitetaam vas alakulmasta
    muoto=ac_objectget("amuoto") 
    if muoto=="Viiste" then
      AddPoint( -gA2, ac_objectget("n1") )
      AddPoint( gA2, ac_objectget("n3") )
    elseif muoto=="Taite" then
      AddPoint( -gA2, ac_objectget("n1") )
      AddPoint( -gA2+ac_objectget("ataite"), ac_objectget("n2") )
      AddPoint( gA2, ac_objectget("n3") )
    else
      AddPoint( -gA2, 0 )
      AddPoint( gA2, 0 )
    end

    -- Yläreuna oikealta vasemmalle
    muoto=ac_objectget("ymuoto") 
    if muoto=="Viiste" then
      AddPoint( gA2, gB-ac_objectget("p3") )
      AddPoint( -gA2, gB-ac_objectget("p1") )
    elseif muoto=="Taite" then
      AddPoint( gA2, gB-ac_objectget("p3") )
      AddPoint( -gA2+ac_objectget("ytaite"), gB-ac_objectget("p2") )
      AddPoint( -gA2, gB-ac_objectget("p1") )
    else
      AddPoint( gA2, gB )
      AddPoint( -gA2, gB )
    end
    
    return true
  end

  return false
end


-- Handles windows having angled top with parameter SR defining left side height
function DoHonkaAngled()
  local h
  
  h=ac_objectget("SR")    -- Height of edge (defailt
  if h==nil then
    return false
  end
  
  AddPoint( -gA2, 0 )   -- left bottom
  AddPoint( gA2, 0 )    -- right bottom
  AddPoint( gA2, gB )   -- right top
  AddPoint( -gA2, h )   -- left top
  return true
end



-- Handles windows triangle top asymmetric
function DoHonkaTriangleAsym()
  local yLeft, yRight, xMid
  
  yLeft=ac_objectget("SR") 
  yRight=ac_objectget("SL") 
  xMid=ac_objectget("TS") 
  if yLeft==nil or yRight==nil or xMid==nil then
    return false
  end
  
  AddPoint( -gA2, 0 )   -- left bottom
  AddPoint( gA2, 0 )    -- right bottom
  AddPoint( gA2, yRight )   -- right top
  AddPoint( gA2-xMid, gB )   -- mid top
  AddPoint( -gA2, yLeft )   -- left top
  return true
end


-- Handles windows triangle top asymmetric
function DoHonkaTriangleSym()
  local y
  
  y=ac_objectget("SI") 
  if y==nil then
    return false
  end
  
  AddPoint( -gA2, 0 )   -- left bottom
  AddPoint( gA2, 0 )    -- right bottom
  AddPoint( gA2, y )   -- right top
  AddPoint( 0, gB )   -- mid top
  AddPoint( -gA2, y )   -- left top
  return true
end


-- Handles HONKA WINDOW 11/2012
function DoHonkaWindow()
  local s
  local y
  
  
  s=ac_objectget("windowname")
  if s==nil then
    return false
  end
  s=string.lower(s)

  if s=="angle" or s=="angle b" then
    local h

    h=ac_objectget("SR")    -- Height of edge (defailt
    if h==nil then
      return false
    end
    
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, gB )   -- right top
    AddPoint( -gA2, h )   -- left top
    return true
  end
  
  if s=="triangle" then
    local yLeft, yRight, xMid
    
    yLeft=ac_objectget("SR") 
    yRight=ac_objectget("SL") 
    xMid=ac_objectget("TS") 
    if yLeft==nil or yRight==nil or xMid==nil then
      return false
    end
    
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, yRight )   -- right top
    AddPoint( gA2-xMid, gB )   -- mid top
    AddPoint( -gA2, yLeft )   -- left top
    return true
  end
  
  if s=="windowdoor" then
    gForceType=5    -- Door
  end

  if s=="empty-window" then
    gPoints=nil
    return true
  end

  return false
end


-- Lasita window 5/2018
function DoLasita()
  local shape, angle, h2, w2
  
  shape=ac_objectget("shape")
  angle=ac_objectget("angle")
  h2=ac_objectget("height2")
  w2=ac_objectget("width2")
  if shape=="2 Triangle top" then
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, h2 )
    AddPoint( 0, gB )
    AddPoint( -gA2, h2 )
    return true
  end

  if shape=="3 Rakehead top" then
    AddPoint( -gA2, 0 )
    AddPoint( gA2, 0 )
    AddPoint( gA2, gB )
    AddPoint( -gA2, h2 )
    return true
  end

  if shape=="4 Left/right triangle" then
    AddPoint( -gA2, 0 )
    AddPoint( gA2, 0 )
    AddPoint( gA2, gB )
    return true
  end

  if shape=="5 Triangle" then
    AddPoint( -gA2, 0 ) 
    AddPoint( 0, gB ) 
    AddPoint( gA2, 0 )
    return true
  end

  if shape=="6 Flat top triangle" then
--ac_environment("tolog", string.format("w2=%f h2=%f", w2, h2))
    AddPoint( -gA2, 0 ) 
    AddPoint( gA2, 0 )
    AddPoint( gA2, h2 )
    w2=gA2-w2*0.5
    AddPoint( gA2-w2, gB )
    AddPoint( -gA2+w2, gB )
    AddPoint( -gA2, h2 )
    return true
  end

  if shape=="8 Left/right trapezoid" then
    AddPoint( -gA2, 0 ) 
    AddPoint( gA2, 0 )
    AddPoint( -gA2+w2, gB )
    AddPoint( -gA2, gB )
    return true
  end

  return false
end


-- Lasita having frame outline as polygon
function DoLasita2021()
  local rows, i, x, y, mask, xoff, yoff, s
  
  rows=ac_objectget("ulkoreuna",-1)
--ac_environment("tolog", string.format("rows=%s gA=%f gB=%f", tostring(rows), gA, gB))
  if not rows then
    return false
  end
  
  xoff=0
  yoff=0
  s=ac_objectget("tyyppi")
  if not s then 
    s=""
  end
--ac_environment("tolog", s)
  if s=="Wooden" then
    xoff=0.028
    yoff=0.028
  elseif s=="Aluminium" or s=="Aluminum" then
    xoff=0.033
    yoff=0.033
  end

  for i=1,rows do
    x=ac_objectget("ulkoreuna",i,1)+xoff
    y=ac_objectget("ulkoreuna",i,2)+yoff
    mask=ac_objectget("ulkoreuna",i,3)
    AddPoint( gA2-x, y )    -- Flip x
--ac_environment("tolog", string.format("x=%f y=%f", x, y))
  end
  return true
end


-- Pihla window 12/2019
function DoPihla()
  local shape, angle, h2, h3, w2, w3
  
  shape=ac_objectget("muoto_tyyppi")
  angle=ac_objectget("angle")
  w2=ac_objectget("a_2")
  w3=ac_objectget("a_3")
  h2=ac_objectget("b_2")
  h3=ac_objectget("c_3")
  
  if shape==2 then
    -- Terävä yläosa
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, h2 )
    AddPoint( gA2-w2, gB )
    AddPoint( -gA2, h3 )
    return true
  end

  if shape==3 then
    -- Kallistettu yläosa
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, gB )
    AddPoint( -gA2, h2 )
    return true
  end

  if shape==4 then
    -- Kolmio
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, gB )
    return true
  end

  if shape==5 then
    -- Kolmio
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2-w2, gB )
    return true
  end

  if shape==6 then
    -- Suora yläosa viisteen reunoilla
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, h2 )
    AddPoint( gA2-w2, gB )
    AddPoint( -gA2+w3, gB )
    AddPoint( -gA2, h3 )
    return true
  end

  if shape==7 then
    -- Suora yläosa viisteet reunoilla alas asti
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2-w2, gB )
    AddPoint( -gA2+w3, gB )
    return true
  end

  if shape==8 then
    -- Toinen reuna vino
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, gB )
    AddPoint( gA2-w2, gB )
    return true
  end
  
  local d, is

  is=ac_objectget("levike")
  d=ac_objectget("levike_a")
  if is and d and is~=0 and d>0.001 then
    -- Pihlassa tämä leventää ikkunaa
    gA=gA+d
    gA2=gA2+d*0.5
    AddPoint( -gA2, 0 )   -- left bottom
    AddPoint( gA2, 0 )    -- right bottom
    AddPoint( gA2, gB )
    AddPoint( -gA2, gB )
    return true
  end  

  return false
end

]]>
    </openings_script>
  </cover>

</archiframe>
